name: Snowflake Deploy (Release folder only)

on:
  push:
    branches: [ develop, main ]
    tags: [ "v*" ]
    paths:
      - "release/**"
  workflow_dispatch:

permissions:
  contents: read
  id-token: write   # REQUIRED for OIDC
  actions: read

concurrency:
  group: snowflake-deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    environment: ${{ startsWith(github.ref, 'refs/tags/') && 'snowflake-odw-prod' || (github.ref == 'refs/heads/main' && 'snowflake-odw-uat') || 'snowflake-odw-dev' }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 0) Hard stop if this run is not actually related to release folder changes.
      # (paths filter already does this, but this protects workflow_dispatch / edge cases)

      - name: Print ref info
        run: |
        echo "Full ref: ${{ github.ref }}"
        echo "Ref name: ${{ github.ref_name }}"
        echo "SHA: ${{ github.sha }}"
    
      - name: Ensure release folder changed (skip otherwise)
        if: github.event_name != 'workflow_dispatch'
        run: |
          set -euo pipefail
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            # For tags, you may still want to deploy even if changes aren't detected here.
            # Keep allowed for tags.
            echo "Tag build: proceeding."
            exit 0
          fi

          # Compare last commit range for push event
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"
          echo "Diff range: $BEFORE..$AFTER"
          CHANGED=$(git diff --name-only "$BEFORE" "$AFTER" || true)
          echo "$CHANGED"

          if ! echo "$CHANGED" | grep -qE '^release/'; then
            echo "No changes under release/. Skipping."
            exit 0
          fi

      # 1) Determine deploy env string
      - name: Set DEPLOY_ENV
        run: |
          set -euo pipefail
          if [[ "${GITHUB_REF}" == refs/tags/* ]]; then echo "DEPLOY_ENV=prod" >> $GITHUB_ENV;
          elif [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then echo "DEPLOY_ENV=uat" >> $GITHUB_ENV;
          else echo "DEPLOY_ENV=dev" >> $GITHUB_ENV; fi

      # 2) Read config from odw.yml
      - name: Read odw.yml config
        run: |
          set -euo pipefail
          python - <<'PY' >> "$GITHUB_ENV"
          import os, yaml
          env=os.environ["DEPLOY_ENV"]
          with open("config/odw.yml","r") as f:
            cfg=yaml.safe_load(f)
          e=cfg["environments"][env]
          sf=e["snowflake"]
          print(f"SNOWFLAKE_ACCOUNT={sf['account']}")
          print(f"SNOWFLAKE_DATABASE={sf['database']}")
          print(f"SNOWFLAKE_SCHEMA={sf['schema']}")
          print(f"SNOWFLAKE_WAREHOUSE={sf['warehouse']}")
          print(f"SNOWFLAKE_ROLE={sf['role']}")
          print(f"AWS_SECRET_NAME={e['aws_secret_name']}")
          PY
        shell: bash

      # 3) Configure AWS credentials via OIDC
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ vars.AWS_REGION }}

      # 4) Export Snowflake secrets to env (fixed env wiring + robust validation)
      - name: Export Snowflake secrets to env
        run: |
          set -euo pipefail
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$AWS_SECRET_NAME" \
            --query SecretString --output text)

          python - <<'PY'
          import os, json, sys
          s=json.loads(os.environ["SECRET_JSON"])
          required=["SNOWFLAKE_USER"]
          missing=[k for k in required if k not in s or not s[k]]
          if missing:
            print(f"Missing required keys in secret: {missing}", file=sys.stderr)
            sys.exit(2)

          # Decide auth method
          has_key = bool(s.get("SNOWFLAKE_PRIVATE_KEY_P8"))
          has_pwd = bool(s.get("SNOWFLAKE_PASSWORD"))

          if not (has_key or has_pwd):
            print("Secret must include either SNOWFLAKE_PRIVATE_KEY_P8 or SNOWFLAKE_PASSWORD", file=sys.stderr)
            sys.exit(3)

          # Append to GITHUB_ENV
          env_path=os.environ["GITHUB_ENV"]
          with open(env_path, "a") as f:
            f.write(f"SNOWFLAKE_USER={s['SNOWFLAKE_USER']}\n")
            if has_key:
              f.write("AUTH_METHOD=KEYPAIR\n")
              key_path="/tmp/sf_key.p8"
              with open(key_path,"w") as kf:
                kf.write(s["SNOWFLAKE_PRIVATE_KEY_P8"])
              os.chmod(key_path, 0o600)
              f.write(f"SNOWFLAKE_PRIVATE_KEY_PATH={key_path}\n")
              if s.get("SNOWFLAKE_PRIVATE_KEY_PASSPHRASE"):
                f.write(f"SNOWFLAKE_PRIVATE_KEY_PASSPHRASE={s['SNOWFLAKE_PRIVATE_KEY_PASSPHRASE']}\n")
            else:
              f.write("AUTH_METHOD=PASSWORD\n")
              f.write(f"SNOWFLAKE_PASSWORD={s['SNOWFLAKE_PASSWORD']}\n")
          PY
        env:
          SECRET_JSON: ${{ steps.getsecret.outputs.secret_json }}
        shell: bash

      # (Helper) Fetch secret JSON and set as output for the python step above
      - name: Get AWS secret JSON
        id: getsecret
        run: |
          set -euo pipefail
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id "$AWS_SECRET_NAME" \
            --query SecretString --output text)
          echo "secret_json<<EOF" >> $GITHUB_OUTPUT
          echo "$SECRET_JSON" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      # 5) Install snowsql
      - name: Install snowsql
        run: |
          set -euo pipefail
          curl -L -o snowsql.bash https://sfc-repo.snowflakecomputing.com/snowsql/bootstrap/1.2/linux_x86_64/snowsql-1.2.31-linux_x86_64.bash
          bash snowsql.bash -y
          echo "$HOME/bin" >> $GITHUB_PATH

      # 6) Guardrail: prod tags only allowed from main
      - name: Guardrail - prod tag must be on main
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          set -euo pipefail
          git fetch origin main --depth=1
          git merge-base --is-ancestor "$GITHUB_SHA" origin/main

      # 7) Run deployment â€” ONLY release folder scripts
      - name: Deploy release folder
        run: |
          set -euo pipefail
          REF_NAME="$GITHUB_REF_NAME"
          if [[ "$DEPLOY_ENV" == "prod" ]]; then GIT_REF="$REF_NAME"; else GIT_REF="$GITHUB_REF_NAME"; fi

          # choose the entry-point script inside release/
          # Example: release/run.sql (adjust to your repo)
          SCRIPT_PATH="release/run.sql"

          if [[ "$AUTH_METHOD" == "KEYPAIR" ]]; then
            snowsql -a "$SNOWFLAKE_ACCOUNT" -u "$SNOWFLAKE_USER" \
              --private-key-path "$SNOWFLAKE_PRIVATE_KEY_PATH" \
              -q "
                USE DATABASE ${SNOWFLAKE_DATABASE};
                USE SCHEMA ${SNOWFLAKE_SCHEMA};
                USE WAREHOUSE ${SNOWFLAKE_WAREHOUSE};
                USE ROLE ${SNOWFLAKE_ROLE};

                CALL GITOPS.EXECUTE_FROM_GIT(
                  '${SCRIPT_PATH}',
                  'CR-AUTO',
                  'GitHub Actions deploy (release folder)',
                  '${GIT_REF}',
                  'EDW_REPO',
                  P_FORCE=>TRUE
                );
              "
          else
            snowsql -a "$SNOWFLAKE_ACCOUNT" -u "$SNOWFLAKE_USER" -p "$SNOWFLAKE_PASSWORD" \
              -q "
                USE DATABASE ${SNOWFLAKE_DATABASE};
                USE SCHEMA ${SNOWFLAKE_SCHEMA};
                USE WAREHOUSE ${SNOWFLAKE_WAREHOUSE};
                USE ROLE ${SNOWFLAKE_ROLE};

                CALL GITOPS.EXECUTE_FROM_GIT(
                  '${SCRIPT_PATH}',
                  'CR-AUTO',
                  'GitHub Actions deploy (release folder)',
                  '${GIT_REF}',
                  'EDW_REPO',
                  P_FORCE=>TRUE
                );
              "
          fi
